// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/aria3ppp/rag-server/internal/vectorstore/usecase (interfaces: Embedder,IDGenerator,VectorRepo,UseCase)
//
// Generated by this command:
//
//	mockgen -destination=mocks/mocks.go -package=mocks -typed . Embedder,IDGenerator,VectorRepo,UseCase
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	domain "github.com/aria3ppp/rag-server/internal/vectorstore/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockEmbedder is a mock of Embedder interface.
type MockEmbedder struct {
	ctrl     *gomock.Controller
	recorder *MockEmbedderMockRecorder
	isgomock struct{}
}

// MockEmbedderMockRecorder is the mock recorder for MockEmbedder.
type MockEmbedderMockRecorder struct {
	mock *MockEmbedder
}

// NewMockEmbedder creates a new mock instance.
func NewMockEmbedder(ctrl *gomock.Controller) *MockEmbedder {
	mock := &MockEmbedder{ctrl: ctrl}
	mock.recorder = &MockEmbedderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEmbedder) EXPECT() *MockEmbedderMockRecorder {
	return m.recorder
}

// Embed mocks base method.
func (m *MockEmbedder) Embed(ctx context.Context, texts []string) ([][]float32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Embed", ctx, texts)
	ret0, _ := ret[0].([][]float32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Embed indicates an expected call of Embed.
func (mr *MockEmbedderMockRecorder) Embed(ctx, texts any) *MockEmbedderEmbedCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Embed", reflect.TypeOf((*MockEmbedder)(nil).Embed), ctx, texts)
	return &MockEmbedderEmbedCall{Call: call}
}

// MockEmbedderEmbedCall wrap *gomock.Call
type MockEmbedderEmbedCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockEmbedderEmbedCall) Return(arg0 [][]float32, arg1 error) *MockEmbedderEmbedCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockEmbedderEmbedCall) Do(f func(context.Context, []string) ([][]float32, error)) *MockEmbedderEmbedCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockEmbedderEmbedCall) DoAndReturn(f func(context.Context, []string) ([][]float32, error)) *MockEmbedderEmbedCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockIDGenerator is a mock of IDGenerator interface.
type MockIDGenerator struct {
	ctrl     *gomock.Controller
	recorder *MockIDGeneratorMockRecorder
	isgomock struct{}
}

// MockIDGeneratorMockRecorder is the mock recorder for MockIDGenerator.
type MockIDGeneratorMockRecorder struct {
	mock *MockIDGenerator
}

// NewMockIDGenerator creates a new mock instance.
func NewMockIDGenerator(ctrl *gomock.Controller) *MockIDGenerator {
	mock := &MockIDGenerator{ctrl: ctrl}
	mock.recorder = &MockIDGeneratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIDGenerator) EXPECT() *MockIDGeneratorMockRecorder {
	return m.recorder
}

// NewID mocks base method.
func (m *MockIDGenerator) NewID() (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewID")
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewID indicates an expected call of NewID.
func (mr *MockIDGeneratorMockRecorder) NewID() *MockIDGeneratorNewIDCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewID", reflect.TypeOf((*MockIDGenerator)(nil).NewID))
	return &MockIDGeneratorNewIDCall{Call: call}
}

// MockIDGeneratorNewIDCall wrap *gomock.Call
type MockIDGeneratorNewIDCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIDGeneratorNewIDCall) Return(arg0 string, arg1 error) *MockIDGeneratorNewIDCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIDGeneratorNewIDCall) Do(f func() (string, error)) *MockIDGeneratorNewIDCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIDGeneratorNewIDCall) DoAndReturn(f func() (string, error)) *MockIDGeneratorNewIDCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockVectorRepo is a mock of VectorRepo interface.
type MockVectorRepo struct {
	ctrl     *gomock.Controller
	recorder *MockVectorRepoMockRecorder
	isgomock struct{}
}

// MockVectorRepoMockRecorder is the mock recorder for MockVectorRepo.
type MockVectorRepoMockRecorder struct {
	mock *MockVectorRepo
}

// NewMockVectorRepo creates a new mock instance.
func NewMockVectorRepo(ctrl *gomock.Controller) *MockVectorRepo {
	mock := &MockVectorRepo{ctrl: ctrl}
	mock.recorder = &MockVectorRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVectorRepo) EXPECT() *MockVectorRepoMockRecorder {
	return m.recorder
}

// Insert mocks base method.
func (m *MockVectorRepo) Insert(ctx context.Context, embeddings []*domain.VectorRepoInsertEmbedding) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Insert", ctx, embeddings)
	ret0, _ := ret[0].(error)
	return ret0
}

// Insert indicates an expected call of Insert.
func (mr *MockVectorRepoMockRecorder) Insert(ctx, embeddings any) *MockVectorRepoInsertCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockVectorRepo)(nil).Insert), ctx, embeddings)
	return &MockVectorRepoInsertCall{Call: call}
}

// MockVectorRepoInsertCall wrap *gomock.Call
type MockVectorRepoInsertCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockVectorRepoInsertCall) Return(arg0 error) *MockVectorRepoInsertCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockVectorRepoInsertCall) Do(f func(context.Context, []*domain.VectorRepoInsertEmbedding) error) *MockVectorRepoInsertCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockVectorRepoInsertCall) DoAndReturn(f func(context.Context, []*domain.VectorRepoInsertEmbedding) error) *MockVectorRepoInsertCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockVectorRepo) Query(ctx context.Context, query *domain.VectorRepoQueryInput) ([]*domain.VectorRepoQueryResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", ctx, query)
	ret0, _ := ret[0].([]*domain.VectorRepoQueryResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockVectorRepoMockRecorder) Query(ctx, query any) *MockVectorRepoQueryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockVectorRepo)(nil).Query), ctx, query)
	return &MockVectorRepoQueryCall{Call: call}
}

// MockVectorRepoQueryCall wrap *gomock.Call
type MockVectorRepoQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockVectorRepoQueryCall) Return(arg0 []*domain.VectorRepoQueryResult, arg1 error) *MockVectorRepoQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockVectorRepoQueryCall) Do(f func(context.Context, *domain.VectorRepoQueryInput) ([]*domain.VectorRepoQueryResult, error)) *MockVectorRepoQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockVectorRepoQueryCall) DoAndReturn(f func(context.Context, *domain.VectorRepoQueryInput) ([]*domain.VectorRepoQueryResult, error)) *MockVectorRepoQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockUseCase is a mock of UseCase interface.
type MockUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockUseCaseMockRecorder
	isgomock struct{}
}

// MockUseCaseMockRecorder is the mock recorder for MockUseCase.
type MockUseCaseMockRecorder struct {
	mock *MockUseCase
}

// NewMockUseCase creates a new mock instance.
func NewMockUseCase(ctrl *gomock.Controller) *MockUseCase {
	mock := &MockUseCase{ctrl: ctrl}
	mock.recorder = &MockUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUseCase) EXPECT() *MockUseCaseMockRecorder {
	return m.recorder
}

// InsertTexts mocks base method.
func (m *MockUseCase) InsertTexts(ctx context.Context, input *domain.InsertTextsInput) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertTexts", ctx, input)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertTexts indicates an expected call of InsertTexts.
func (mr *MockUseCaseMockRecorder) InsertTexts(ctx, input any) *MockUseCaseInsertTextsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertTexts", reflect.TypeOf((*MockUseCase)(nil).InsertTexts), ctx, input)
	return &MockUseCaseInsertTextsCall{Call: call}
}

// MockUseCaseInsertTextsCall wrap *gomock.Call
type MockUseCaseInsertTextsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseInsertTextsCall) Return(arg0 error) *MockUseCaseInsertTextsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseInsertTextsCall) Do(f func(context.Context, *domain.InsertTextsInput) error) *MockUseCaseInsertTextsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseInsertTextsCall) DoAndReturn(f func(context.Context, *domain.InsertTextsInput) error) *MockUseCaseInsertTextsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SearchText mocks base method.
func (m *MockUseCase) SearchText(ctx context.Context, input *domain.SearchTextInput) (*domain.SearchTextResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SearchText", ctx, input)
	ret0, _ := ret[0].(*domain.SearchTextResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SearchText indicates an expected call of SearchText.
func (mr *MockUseCaseMockRecorder) SearchText(ctx, input any) *MockUseCaseSearchTextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SearchText", reflect.TypeOf((*MockUseCase)(nil).SearchText), ctx, input)
	return &MockUseCaseSearchTextCall{Call: call}
}

// MockUseCaseSearchTextCall wrap *gomock.Call
type MockUseCaseSearchTextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUseCaseSearchTextCall) Return(arg0 *domain.SearchTextResult, arg1 error) *MockUseCaseSearchTextCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUseCaseSearchTextCall) Do(f func(context.Context, *domain.SearchTextInput) (*domain.SearchTextResult, error)) *MockUseCaseSearchTextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUseCaseSearchTextCall) DoAndReturn(f func(context.Context, *domain.SearchTextInput) (*domain.SearchTextResult, error)) *MockUseCaseSearchTextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
